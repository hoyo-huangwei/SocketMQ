// Generated by CoffeeScript 1.4.0

/*
Context class use to create different type of sockets and abstract the transport layer.
*/


(function() {
  var Context, EventEmitter, Socket, debug, engine, engineClient, http, qsParse, sockets, types, urlParse, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require('http');

  engine = require('engine.io');

  engineClient = require('engine.io-client');

  debug = require('debug')('socketmq:context');

  EventEmitter = require('events').EventEmitter;

  _ref = require('./sockets'), types = _ref.types, Socket = _ref.Socket, sockets = _ref.sockets;

  qsParse = require('querystring').parse;

  urlParse = require('url').parse;

  Context = (function(_super) {

    __extends(Context, _super);

    function Context(options) {
      this.options = options;
      this.sockets = {};
      this.connections = {};
    }

    Context.prototype.socket = function(type, options) {
      var Sock;
      Sock = sockets[type];
      if ('function' !== typeof Sock) {
        throw new Error('Unknow socket type "' + type + '"');
      }
      return new Sock(this, options);
    };

    Context.prototype.connect = function(url, options) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if ('string' === typeof url) {
        options.path = options.path || '/socketmq';
        this.client = engineClient(url, options);
      } else {
        this.client = url;
      }
      this.client.on('handshake', function(data) {
        return debug('client handling handshake data %j', data);
      });
      return this;
    };

    Context.prototype.handshake = function(socket) {
      /*
            when received handshake data from server
            add socket info to received data and send an "open" packet to server
            the server will reply an "open" packet with server endpoint info
            or close the connection if the socket type miss match (e.g. connect req to req)
      */

      var _this = this;
      if (this.client.smq) {
        return this.handleConnection(this.client, {
          id: client.id,
          endpoint: socket.endpoint,
          type: socket.type
        });
      } else {
        return this.client.on('open', function(data) {
          var onPacket;
          data = {
            id: _this.client.id,
            endpoint: socket.endpoint,
            type: socket.type,
            smq: 0x01
          };
          data = JSON.stringify(data);
          onPacket = function(packet) {
            if ('noop' === packet.type) {
              data = JSON.parse(packet.data);
              if (data.smq) {
                debug('client got noop packet data from server: %s', packet.data);
                _this.client.smq = data.smq;
                _this.client.removeListener('packet', onPacket);
                return _this.handleConnection(_this.client, data);
              }
            }
          };
          _this.client.on('packet', onPacket);
          debug('client sending noop packet to server with data %s', data);
          return _this.client.sendPacket('noop', data);
        });
      }
    };

    Context.prototype.listen = function(port, host, options, fn) {
      var httpServer, opts,
        _this = this;
      opts = {
        path: '/socketmq'
      };
      if (!fn) {
        if ('function' === typeof options) {
          fn = options;
          options = null;
        } else if ('function' === typeof host) {
          fn = host;
          host = null;
        }
      }
      if (typeof port === 'number') {
        httpServer = http.createServer(options);
        httpServer.listen(port, host);
        this.server = engine.attach(httpServer, opts);
        this.server.httpServer = httpServer;
      } else if (port instanceof http.Server) {
        this.server = engine.attach(port, opts);
        this.server.httpServer = port;
      } else {
        fn({
          code: 'EINVALIDARGS',
          message: "First argument of Context#listen must be instance of http.Server or port number"
        });
        return this;
      }
      this.server.httpServer.on('listening', function() {
        var args, callback, endpoint, socket, _ref1, _results;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        fn && fn.apply(null, args);
        _ref1 = _this.sockets;
        _results = [];
        for (endpoint in _ref1) {
          socket = _ref1[endpoint];
          _results.push((function() {
            var _i, _len, _ref2, _results1;
            _ref2 = socket.bindCallbacks;
            _results1 = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              callback = _ref2[_i];
              _results1.push(callback.apply(null, args));
            }
            return _results1;
          })());
        }
        return _results;
      });
      this.server.on('connection', function(conn) {
        var onPacket;
        debug('server handling new connection ', conn.id);
        onPacket = function(packet) {
          var data;
          if ('noop' === packet.type) {
            data = JSON.parse(packet.data);
            if (data.smq) {
              debug('server got handshake data from client: %s', packet.data);
              conn.smq = data.smq;
              conn.removeListener('packet', onPacket);
              return _this.handleConnection(conn, data);
            }
          }
        };
        return conn.on('packet', onPacket);
      });
      return this;
    };

    Context.prototype.setSocket = function(endpoint, socket) {
      if (__indexOf.call(this.sockets, endpoint) >= 0) {
        throw new Error('Endpoint ' + endpoint + ' already in use');
      }
      this.sockets[endpoint] = socket;
      return this;
    };

    Context.prototype.getSocket = function(endpoint) {
      return endpoint && this.sockets[endpoint];
    };

    Context.prototype.handleConnection = function(conn, meta) {
      var connMeta, connections, data, endpoint, id, k, socket, type, v;
      if (conn.smq) {
        id = meta.id, endpoint = meta.endpoint, type = meta.type;
        socket = this.getSocket(endpoint);
        if (!socket) {
          debug('Unknow destination endpoint');
          return conn.close();
        } else if (socket.accept(type)) {
          if (conn.server) {
            data = {};
            for (k in meta) {
              v = meta[k];
              data[k] = v;
            }
            data.type = socket.type;
            data = JSON.stringify(data);
            debug('server send noop packet to client %s', data);
            conn.sendPacket('noop', data);
          }
          connections = this.connections;
          if (!connections[endpoint]) {
            connections[endpoint] = {};
          }
          connMeta = {
            id: id,
            endpoint: endpoint,
            type: type
          };
          if (!connections[endpoint][id]) {
            connections[endpoint][id] = conn;
            conn.once('close', function(reason, info) {
              if (connections[endpoint][id]) {
                debug('Engine.io client socket closed: %s', reason);
                delete connections[endpoint][id];
                socket.handleDisconnect(connMeta);
                return this.emit('disconnect', connMeta);
              } else {
                return debug('Closing an inexistent engine.io socket');
              }
            });
          }
          conn.on('message', function(data) {
            return socket.handleMessage(connMeta, data);
          });
          return socket.handleConnect(connMeta);
        } else {
          debug('Not accepted socket type: %s', type);
          return conn.close();
        }
      } else {
        debug('Not a SocketMQ connection, closing...');
        return conn.close();
      }
    };

    Context.prototype.send = function(socket, conn, data) {
      var connection;
      if (this.connections[conn.endpoint] && this.connections[conn.endpoint][conn.id]) {
        connection = this.connections[conn.endpoint][conn.id];
        return connection.send(data);
      } else {
        return debug('Writing data to an inexistent connection %s at endpoint %s', conn.id, conn.endpoint);
      }
    };

    Context.prototype.close = function() {
      var k, sock, _ref1;
      _ref1 = this.sockets;
      for (k in _ref1) {
        sock = _ref1[k];
        sock.close();
      }
      if (this.server) {
        this.server.close();
      }
      if (this.client) {
        return this.client.close();
      }
    };

    return Context;

  })(EventEmitter);

  module.exports = Context;

}).call(this);
