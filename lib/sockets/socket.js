// Generated by CoffeeScript 1.4.0
(function() {
  var EventEmitter, Socket, debug, types,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  EventEmitter = require('events').EventEmitter;

  debug = require('debug')('socketmq:socket');

  /*
  Types of socket
  */


  types = exports.types = {
    pair: 0x00,
    pub: 0x01,
    sub: 0x02,
    req: 0x03,
    rep: 0x04,
    dealer: 0x05,
    router: 0x06,
    pull: 0x07,
    push: 0x08
  };

  /*
  Base class for different socket patterns
  */


  Socket = (function(_super) {

    __extends(Socket, _super);

    function Socket(context, type, options) {
      if (types[type] === void 0) {
        throw new Error('Unknow socket type "' + type + '"');
      }
      this.context = context;
      this.type = types[type];
      this.outBuffer = [];
      this.connections = [];
      this.bindCallbacks = [];
    }

    Socket.prototype.connect = function(url) {
      this.context.setSocket(url, this);
      this.endpoint = url;
      return this.context.handshake(this);
    };

    Socket.prototype.bind = function(endpoint, callback) {
      this.context.setSocket(endpoint, this);
      if ('function' === typeof callback) {
        return this.bindCallbacks.push(callback);
      }
    };

    Socket.prototype.setsockopt = function(name, value) {};

    Socket.prototype.getsockopt = function(name) {};

    Socket.prototype.accept = function(type) {
      var _ref;
      type = (_ref = types[type]) != null ? _ref : type;
      switch (this.type) {
        case types.pair:
          return type === types.pair;
        case types.pub:
          return type === types.sub;
        case types.sub:
          return type === types.pub;
        case types.req:
          return type === types.rep || type === types.router;
        case types.rep:
          return type === types.req || type === types.dealer;
        case types.dealer:
          return type === types.rep || type === types.dealer || type === types.router;
        case types.router:
          return type === types.req || type === types.dealer || type === types.router;
        case types.pull:
          return type === types.push;
        case types.push:
          return type === types.pull;
      }
    };

    Socket.prototype.drop = function(msg, reason) {
      debug('Message "' + msg + '" dropped due to ' + (reason != null ? reason : 'unknow reason'));
      return this.emit('drop', msg, reason);
    };

    Socket.prototype.handleConnect = function(conn) {
      if (__indexOf.call(this.connections, conn) < 0) {
        this.connections.push(conn);
      }
      return this.emit('connect', conn);
    };

    Socket.prototype.handleDisconnect = function(conn) {
      var idx;
      idx = this.connections.indexOf(conn);
      if (idx > -1) {
        this.connections.splice(idx, 1);
        return this.emit('disconnect', conn);
      }
    };

    Socket.prototype.close = function() {
      if (!this.closed) {
        this.closed = true;
        this.emit('close');
        this.connections = [];
        return this.outBuffer = [];
      }
    };

    Socket.prototype.flushRoundRobin = function(data) {
      if (this.connections.length > 0 && !this.flushing) {
        this.flushing = true;
        if ('undefined' !== typeof data) {
          this.outBuffer.push(data);
        }
        while (this.connections.length > 0 && this.outBuffer.length > 0) {
          this.context.send(this, this.connections.shift(), this.outBuffer.shift());
        }
        return this.flushing = false;
      } else if ('undefined' !== typeof data) {
        if (this.outBuffer.length >= this.hwm) {
          return this.drop(data, 'high water mark reached (#{@hwm})');
        } else {
          return this.outBuffer.push(data);
        }
      }
    };

    return Socket;

  })(EventEmitter);

  exports.Socket = Socket;

}).call(this);
